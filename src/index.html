<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- <title>Todo List</title> -->
    </head>
    <body>
        <!-- <h1>Todo List</h1>
        <div class="search">
            <input type="text" id="searchInput" placeholder="Пошук за ім'ям" />
            <button id="searchButton">Пошук</button>
        </div>
        <div class="sort">
            <label for="sortSelect">Сортування за статусом:</label>
            <select id="sortSelect">
                <option value="completedFirst">Виконані спочатку</option>
                <option value="notCompletedFirst">Невиконані спочатку</option>
            </select>
            <button id="sortButton">Сортувати</button>
        </div>
        <div class="todo-form">
            <input
                type="text"
                id="noteInput"
                placeholder="Додайте нову примітку" />
            <button id="addButton">Добавити</button>
        </div>
        <div id="noteList" class="todo-list"></div>
        <div class="summary">
            <p>Усього приміток: <span id="totalNotes">0</span></p>
            <p>Залишилося невиконаних: <span id="remainingNotes">0</span></p>
            <p>Виконано: <span id="completedNotesCount">0</span></p>
        </div> -->

        <script src="main.js"></script>
    </body>
</html>

<!-- // "number" + 23 + 32;
console.log("number" + 23 + 32);
// "number" перетворюється в рядок, потім конкатенується з 23 та 32
// "number2332"

// 41 + 1 + "number";
console.log(41 + 1 + "number");
// 41 + 1 дорівнює 42, потім конкатенується з "number"
// "42number"

// null + 1;
console.log(null + 1);
// null перетворюється в 0, потім додається 1
// 1

// "five" + +"two";
console.log("five" + +"two");
// відбувається конкатенація рядка "five" з результатом унарного плюсу перед "two".
// унарний плюс перед "two" намагається перетворити його на число, але оскільки "two" не є числом, результат буде NaN.
// "fiveNan"

// 2 && 7;
console.log(2 && 7);
//Оскільки обидва числа 2 та 7 є істинними (true) значеннями результат операції і (&&) буде 7.
// 7

//+"40" + +"2";
console.log(+"40" + +"2");
// +"40" перетворюється в число 40, +"2" перетворюється в число 2.
// 42

// "10" - 5 === 6;
console.log("10" - 5 === 6);
// "10" - 5 дорівнює 5, що не дорівнює 6.
// false

// true + false;
console.log(true + false);
// true перетворюється в 1, false перетворюється в 0.
// 1

// '4px' - 3;
console.log("4px" - 3);
// '4px' не може бути перетворено в число.
// NaN

// '4' - 3;
console.log("4" - 3);
// '4' перетворюється в число 4.
// 1

// "2" + 3 ** 2;
console.log("2" + 3 ** 2);
// 3 ** 2 дорівнює 9, потім конкатенується з "2".
// "29"

// 12 / "6";
console.log(12 / "6");
// "6" перетворюється в число 6.
// 2

// 23 + 42 + "number";
console.log(23 + 42 + "number");
// 23 + 42 дорівнює 65, потім конкатенується з "number".
// "65number"

// "10" + (5 === 6);
console.log("10" + (5 === 6));
// Результат виразу 5 === 6 - це false, а "10" перетворюється в "10"
// "10false"

// "number" + 15 + 3;
console.log("number" + 15 + 3);
// "number" перетворюється в рядок, потім конкатенується з 15 та 3.
// "number153"

// undefined + 1;
console.log(undefined + 1);
// undefined перетворюється в NaN, потім додається 1.
// NaN

// null == "";
// null та пустий рядок "" не дорівнюють один одному.
console.log(null == "");
// false

// 3 ** (9 / 3);
console.log(3 ** (9 / 3));
//спочатку відбувається обчислення виразу у дужках: 9 / 3 дорівнює 3. Потім вираз 3 ** 3
// 27 -->

<!-- // 1 програма
const number = parseInt(prompt("Введіть число:")); //Поле для ввода числа

// Перевіряємо чи число ділиться на 3 та 5
if (number % 3 === 0 && number % 5 === 0) {
  console.log("FizzBuzz");
  // Якщо число ділиться на 3
} else if (number % 3 === 0) {
  console.log("Fizz");
  // Якщо число ділиться на 5
} else if (number % 5 === 0) {
  console.log("Buzz");
} else {
  // Якщо число не ділиться на 3 і 5
  console.log(number); // Виводиця те саме число
}

// 2 програма
const y = parseInt(prompt("Введіть рік:"));
if ((y % 4 === 0 && y % 100 !== 0) || y % 400 === 0) {
  console.log("YES"); // Високосний рік
} else {
  console.log("NO"); // Не високосний рік
}

// Програма 3
// Отримуємо кількість років від користувача
const year = parseInt(prompt("Введіть кількість років:"));
function getYearLabel(number) {
  if (number % 10 === 1 && number % 100 !== 11) {
    return "рік"; // Якщо число закінчується на 1 (окрім 11), то використовуємо форму "рік"
  } else if (
    number % 10 >= 2 &&
    number % 10 <= 4 &&
    (number % 100 < 10 || number % 100 >= 20)
  ) {
    return "роки"; // Якщо закінчується на 2-4 (крім 12-14)
  } else {
    return "років"; // У всіх інших випадках "років"
  }
}
// Викликаємо функцію для визначення правильної форми слова "рік"
const label = getYearLabel(year);

console.log(`${year} ${label}`);
//${year}: Це змінна year, яку ви виводим (кількість років)
//${label}: Це змінна label, яку отримуєм в результаті виклику функції getYearLabel(). -->

<!-- //1 програма

function isExemple(number) {
  // Якщо число <= 1, то воно не є простим числом
  if (number <= 1) return false;
  // 2 та 3 - прості числа
  if (number <= 3) return true;
  // якщо число ділиться на 2 або 3, то воно складене
  if (number % 2 === 0 || number % 3 === 0) return false;
  let i = 5;
  while (i * i <= number) {
    // якщо число ділиться на i або (i + 2) то воно складене
    if (number % i === 0 || number % (i + 2) === 0) return false;
    i += 6;
  }
  return true;
}

const n = parseInt(prompt("Введіть число N:"));

console.log(
  isExemple(n)
    ? `Число ${n} є простим числом.`
    : `Число ${n} не є простим числом.`
);

//2 програма
/*sumOfDivisors - це змінна, яка використовується для обчислення суми всіх дільників числа i в циклі,
який перебирає можливі дільники цього числа.*/
function findPerfectNumbers(N) {
  const perfectNumbers = [];
  // Перебираємо числа від 2 до N
  for (let i = 2; i <= N; i++) {
    // Починаємо з 1, бо кожне число ділиться на 1.
    let sumOfDivisors = 1;

    for (let k = 2; k * k <= i; k++) {
      if (i % k === 0) {
        sumOfDivisors += k;
        // Якщо k не є квадратним коренем числа, то додаємо також його пару
        if (k !== i / k) {
          sumOfDivisors += i / k;
        }
      }
    }
    // Якщо сума дільників дорівнює самому числу, то воно досконале
    if (sumOfDivisors === i) {
      perfectNumbers.push(i);
    }
  }

  return perfectNumbers;
}

const N = parseInt(prompt("Введіть число N:"));
const perfectNumbers = findPerfectNumbers(N);

console.log(
  `Досконалі числа в діапазоні від 1 до ${N}: ${perfectNumbers.join(", ")}`
);

//3 програма

var j = parseInt(prompt("Введіть висоту ялинки:"));
var tree = "";

for (var i = 1; i <= j; i++) {
  // Генеруємо пробіли для вирівнювання
  var spaces = "  ".repeat(j - i);
  // Генеруємо зірочки
  var stars = "* ".repeat(2 * i - 1);
  // Об'єднуємо і додаємо до рядка
  tree += spaces + stars + "\n";
}

alert(tree); -->

<!-- // 1 програма
// Оголошуєм функцію з ім'ям reverseString, яка одразу повертає результат
function reverseString() {
  return prompt("Введіть рядок:").split("").reverse().join("");
  //split("") розбиває рядок на масив окремих символів
  //reverse() змінює порядок елементів на протилежний
  //join("") об'єднує елементи масиву в рядок без роздільника
}
console.log(reverseString());

// //2 програма
//Функція isPalindrome перевіряє, чи є рядок паліндромом
function isPalindrome(str) {
  //Очищуєм рядок від всіх символів, крім літер,
  //і перетворюємо його на нижній регістр для незалежності від регістру
  const cleanedString = str.replace(/[^a-zA-Zа-яА-ЯёЁ]/g, "").toLowerCase();
  ///[^a-zA-Zа-яА-ЯёЁ]/g будь-яким символам, що не є літерами (як латинськими, так і кириличними)
  //g позначає пошук у всьому рядку
  //"" замінюємо символи, які не є літерами, замінюємо їх на порожній рядок, тобто видаляємо їх
  //Обертаєм очищений рядок у зворотному порядку
  const reversedString = cleanedString.split("").reverse().join("");
  //Порівнюєм очищений рядок з обернутим рядком і повертаємо результат
  return cleanedString === reversedString;
}

const inputString = prompt("Введіть рядок для перевірки на паліндром:");
// Викликаємо функцію isPalindrome з введеним рядком і зберігаємо результат
const result = isPalindrome(inputString);
console.log(result ? "Це паліндром" : "Це не паліндром");

//3 програма
// Функція findGCD(a, b) приймає два числа (a і b) і знаходить їхній НСД (найменший спільний дільник)
function findGCD(a, b) {
  while (b !== 0) {
    // Знаходимо залишок від ділення a на b
    const remainder = a % b;
    // Замінюємо a на b
    a = b;
    // Замінюємо b на залишок (нове a % b)
    b = remainder;
  }
  return Math.abs(a);
}
//Перше число
const inputNum1 = parseInt(prompt("Введіть перше число:"));
//Друге число
const inputNum2 = parseInt(prompt("Введіть друге число:"));

// Перевіряєм, ввели дійсні числа (числа, а не текст чи символи)
if (!isNaN(inputNum1) && !isNaN(inputNum2)) {
  // Викликаємо функцію
  const gcd = findGCD(inputNum1, inputNum2);
  // Виводимо результат
  console.log(`НСД чисел ${inputNum1} і ${inputNum2} дорівнює ${gcd}`);
} else {
  //Ввели щось інше, виводимо повідомлення про помилку
  console.log("Ви ввели неправильні числа.");
} -->
<!-- // function camelCase(str) {
  //   // Розділити рядок на слова за всіма можлими роздільниками (пробіли, дефіси, підкреслення тощо)
  //   const words = str.split(/[\s-_]+/);
  
  //   // Перетворити перший символ кожного слова на верхній регістр і об'єднати їх
  //   return words
  //     .map((word, index) => {
  //       return index === 0
  //         ? word.toLowerCase()
  //         : word.charAt(0).toUpperCase() + word.slice(1);
  //     })
  //     .join("");
  // }
  
  // const inputText = prompt("Введіть текст для перетворення на camelCase:");
  
  // if (inputText !== null) {
  //   const camelCased = camelCase(inputText);
  //   console.log("Результат:", camelCased);
  // } -->
<!-- //1 програма
  function doubleLetter(str) {
    /* Розділяєм рядок на масив окремих символів,
     потім застосовуємо функцію map, щоб кожний символ подвоїти.*/
    const doubledChars = str.split("").map((char) => char + char);
    //str.split(""): split("") розбиває рядок str на окремі символи і повертає їх у масиві
    //(char) => char + char бере кожен символ char і об'єднує його сам з собою подвоюючи його
  
    return doubledChars.join("");
    // Об'єднуєм масив знову у рядок
  }
  
  const inputWord = prompt("Введіть слово:");
  
  if (inputWord !== null) {
    const result = doubleLetter(inputWord);
    console.log(result);
  }
  //2 програма
  function padString(str, length, symbol, toLeft = true) {
    /*str: початковий рядок, до якого потрібно додати символи
      length: цільова довжина рядка після додавання символів
      symbol: символ, яким доповнюється рядок
      toLeft (за замовчуванням false): флаг, який вказує, з якого боку додавати символи (true - зліва, false - справа)*/
    if (str.length >= length) {
      return str;
      // Повертаєм вихідний рядок без змін, якщо він вже довший або рівний вказаній довжині
    }
  
    const padding = symbol.repeat(length - str.length);
    // Генеруєм рядок з необхідною кількістю символів
  
    if (toLeft) {
      return padding + str;
      // Додаєм символи зліва
    } else {
      return str + padding;
      // Додаєм символи справа
    }
  }
  
  const inputString = prompt("Введіть рядок:");
  const inputLength = parseInt(prompt("Введіть довжину:"));
  const inputSymbol = prompt("Введіть символ:");
  
  //(true для зліва, false для справа)
  const inputToLeft = confirm("Додавати символи зліва?");
  
  const result = padString(inputString, inputLength, inputSymbol, inputToLeft);
  
  console.log(result);
  
  //3 програма
  // Функція camelCase приймає рядок str та масив роздільників separators
  function camelCase(str, separators) {
    // Розділити рядок на слова за допомогою вказаних роздільників
    const words = str.split(new RegExp(`[${separators}]`));
  
    // Перетворити перший символ кожного слова на верхній регістр
    for (let i = 0; i < words.length; i++) {
      words[i] = words[i].charAt(0).toUpperCase() + words[i].slice(1);
    }
    return words.join("");
  }
  const inputText = prompt("Введіть текст для перетворення на camelCase:");
  
  if (inputText !== null) {
    const separator = prompt("Введіть роздільники (наприклад, -, _, ., тощо):");
  
    const camelCased = camelCase(inputText, separator);
    console.log(camelCased);
  } -->
<!-- // //1 програма
  const inputArray = prompt(
    "Введіть масив елементів, розділених комами (наприклад, 1,2,3,4,5):"
  );
  // Перетворення з введеного масиву в масив чисел
  const originalArray = inputArray.split(",").map(Number);
  //inputArray  розділяє рядок на підстроки, використовуючи кому (,) як роздільник
  //.map(Number) перетворює кожен елемент масиву з рядків у числа
  //reverse() розвертае масив
  originalArray.reverse();
  console.log(originalArray);
  
  //2 програма
  function uniqueValues(array1, array2) {
    //Множини Set з вхідних масивів для видалення дублікатів
    const set1 = new Set(array1);
    const set2 = new Set(array2);
    // Об'єднуєм множини та створюємо нову множину, щоб зберегти унікальні значення
    const uniqueSet = new Set([...set1, ...set2]);
    // Перетворюєм множину у масив, щоб повернути результат у вигляді масиву.
    return Array.from(uniqueSet);
  }
  
  const inputArray1 = prompt(
    "Введіть перший масив (використовуйте кому для розділення значень):"
  );
  const inputArray2 = prompt(
    "Введіть другий масив (використовуйте кому для розділення значень):"
  );
  // Розділяєм введені рядки на масиви та перетворюємо їх елементи на числа.
  const array1 = inputArray1.split(",").map(Number);
  const array2 = inputArray2.split(",").map(Number);
  const uniqueValuesArray = uniqueValues(array1, array2);
  // Сортуєм масив з унікальними значеннями за зростанням.
  uniqueValuesArray.sort((a, b) => a - b);
  
  console.log(uniqueValuesArray);
  
  //3 програма
  function calculateAverageGrade(students) {
    const totalGrade = students.reduce((sum, student) => sum + student.grade, 0);
    // Обчислюєм середній бал як відношення суми балів до кількості студентів
    const averageGrade = totalGrade / students.length;
    return averageGrade;
  }
  // Створюєм порожній масив для зберігання даних про студентів
  const students = [];
  
  function getStudentData() {
    const name = prompt("Введіть ім'я студента:");
    if (name === null) return null;
    // Перевіряємо, чи користувач не скасував введення
    const age = parseInt(prompt("Введіть вік студента:"));
    const grade = parseFloat(prompt("Введіть середній бал студента:"));
  
    return { name, age, grade };
  }
  
  function displayStudentList() {
    console.log("Список студентів:");
    students.forEach((student) => {
      console.log(
        `Ім'я: ${student.name}, Вік: ${student.age}, Бал: ${student.grade}`
      );
    });
  }
  
  while (true) {
    const studentData = getStudentData();
    if (studentData === null) break;
    // Виходимо з циклу, якщо користувач скасував введення
  
    if (
      studentData.name &&
      !isNaN(studentData.age) &&
      !isNaN(studentData.grade)
    ) {
      // Додаєм дані студента до масиву students
      students.push(studentData);
    } else {
      alert("Некоректні дані.");
    }
  }
  
  displayStudentList();
  // Перевіряєм, чи є дані про студентів для обчислення середнього балу
  if (students.length > 0) {
    console.log("Середній бал студентів:", calculateAverageGrade(students));
  } else {
    console.log("Дані про студентів відсутні.");
  }
   -->
<!-- //1 програма
   function capitalizeStrings(stringsArray) {
     const capitalizedArray = [];
     // Створюєм порожній масив для зберігання перетворених рядків
     for (const str of stringsArray) {
       // Перетворюєм поточний рядок, роблячи першу літеру великою (toUpperCase())
       // і решту літер в нижньому регістрі (toLowerCase())
       const capitalizedStr =
         str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
       // Додаєм перетворений рядок до масиву capitalizedArray
       capitalizedArray.push(capitalizedStr);
     }
     // Повертаєм новий масив із перетвореними рядками
     return capitalizedArray;
   }
   const inputString = prompt("Введите строки через запятую (без пробелов):");
   const words = inputString.split(",");
   console.log(capitalizeStrings(words));
   
   //2 програма
   function findCommonElements(array1, array2) {
     /*Використовуєм метод filter для створення нового масиву, в якому лишаються тільки елементи,
       які є в обох вхідних масивах (array1 і array2)*/
     const commonElements = array1.filter((element) => array2.includes(element));
     return commonElements;
   }
   const input1 = prompt(
     "Введіть числа через кому для першого масиву (без пробілів):"
   );
   const input2 = prompt(
     "Введіть числа через кому для другого масиву (без пробілів):"
   );
   
   const array1 = input1.split(",").map(Number);
   const array2 = input2.split(",").map(Number);
   
   console.log(findCommonElements(array1, array2));
   
   //3 програма
   function analyzeArray(numbersArray) {
     // Використовуєм деструктуризацію для одразу отримати мінімальне та максимальне значення
     const { min, max } = numbersArray.reduce(
       (acc, num) => ({
         min: Math.min(acc.min, num),
         max: Math.max(acc.max, num),
       }),
       { min: Infinity, max: -Infinity }
     );
     // Обчислюєм суму елементів масиву за допомогою метода reduce
     const sum = numbersArray.reduce((acc, num) => acc + num, 0);
     // Обчислюєм середнє значення елементів, поділяючи суму на кількість елементів
     const average = sum / numbersArray.length;
     // Об'єкт з обчисленими значеннями
     return {
       sum,
       average,
       min,
       max,
     };
   }
   const input = prompt("Введіть числа через кому (без пробілів):");
   const numbers = input.split(",").map(Number);
   console.log(analyzeArray(numbers)); -->
<!-- // //1 програма
function isPrime(num) {
  if (num <= 1) {
    // Якщо число менше або дорівнює 1, воно не є простим
    return false;
  }
  for (let i = 2; i <= Math.sqrt(num); i++) {
    // Перевіряєм дільники від 2 до квадратного кореня з числа
    if (num % i === 0) {
      // Якщо знайдено дільник, число не є простим
      return false;
    }
  }
  // Якщо жодний дільник не знайдений, число є простим
  return true;
}
function filterPrimesWithInput() {
  const input = prompt("Введіть числа через кому (без пробілів):");
  const numbersArray = input.split(",").map(Number);
  const primeNumbers = numbersArray.filter((num) => isPrime(num));
  return primeNumbers;
}

const primeNumbers = filterPrimesWithInput();
console.log("Прості числа: " + primeNumbers.join(", "));

//2 програма
function transformNotifications() {
  const notificationsArray = [];
  // Запитуєм користувача про сповіщення, поки він не введе "exit"
  while (true) {
    const source = prompt(
      "Введіть джерело сповіщення (або введіть 'exit' для завершення):"
    );

    if (source === "exit") {
      // Якщо користувач ввів "exit", завершуємо цикл
      break;
    }

    const text = prompt("Введіть текст сповіщення:");
    const date = prompt("Введіть дату сповіщення:");
    const notification = { source, text, date };
    notificationsArray.push(notification);
  }
  const transformedObject = notificationsArray.reduce((acc, notification) => {
    const source = notification.source;

    // Використовуємо оператор nullish (??), щоб перевірити, чи вже існує масив для даного джерела
    // Якщо масив не існує, то створюємо новий порожній масив
    acc[source] ??= [];
    acc[source].push(notification);

    return acc;
  }, {});

  return transformedObject;
}
const transformedData = transformNotifications();
console.log(transformedData);

//3 програма
function groupArrayByKey(inputArray, key) {
  const groupedObject = {};
  // Проходим по каждому объекту во входном массиве
  for (const item of inputArray) {
    // Получаем значение ключа для текущего объекта
    const keyValue = item[key];
    // Если группа с данным значением ключа еще не существует, создаем ее как пустой массив
    if (!groupedObject[keyValue]) {
      groupedObject[keyValue] = [];
    }
    // Добавляем текущий объект в соответствующую группу
    groupedObject[keyValue].push(item);
  }
  // Возвращаем объект с группированными данными
  return groupedObject;
}

// Пустой объект, в котором будем хранить все группы объектов
const allGroups = {};

while (true) {
  // Запрашиваем у пользователя ключ для группировки объектов
  const key = prompt(
    "Введите ключ для группировки объектов (или 'exit' для завершения):"
  );

  if (key === "exit") {
    // Если пользователь ввел "exit", завершаем ввод
    break;
  }
  const numberOfObjects = parseInt(
    prompt("Введите количество объектов в текущей группе:")
  );
  const inputArray = [];
  for (let i = 0; i < numberOfObjects; i++) {
    const item = {};
    item[key] = prompt(`Введите значение ключа для элемента ${i + 1}:`);
    inputArray.push(item);
  }

  const groupedData = groupArrayByKey(inputArray, key);
  allGroups[key] = groupedData;

  console.log("Текущие группы:", allGroups);
}

console.log("Все группы:", allGroups);
 -->
<!-- //1 програма
// Функція для отримання сповіщень від користувача
function getNotifications() {
  const notifications = [];
  while (true) {
    const source = prompt(
      "Введіть джерело повідомлення (або натисніть 'Скасувати' для завершення):"
    );
    if (source === null || source.trim() === "") {
      // Вихід з циклу, якщо користувач натиснув "Відміна" або залишив поле порожнім
      break;
    }
    const text = prompt("Введіть текст повідомлення:");
    const date = prompt("Введіть дату повідомлення:");
    const notification = { source, text, date };
    notifications.push(notification);
  }
  // Створюємо ітератор для повідомлення
  const iterator = {
    [Symbol.iterator]() {
      let index = 0;
      return {
        next() {
          if (index < notifications.length) {
            return { value: notifications[index++], done: false };
          } else {
            return { done: true };
          }
        },
      };
    },
  };
  return iterator;
}
const notifications = getNotifications();
// Ітеруємося по повідомлення і виводимо їх на консоль
for (const notification of notifications) {
  console.log(`Джерело: ${notification.source}`);
  console.log(`Текст: ${notification.text}`);
  console.log(`Дата: ${notification.date}`);
  console.log("=========================================");
}

// 2 програма
function memoize(fn) {
  //Создаем объект cache для хранения кеша результатов вычислений
  const cache = new Map();
  //Возвращаем новую функцию которая будет выполнять кеширование
  return function (...args) {
    //Создаем ключ для кеширования на основе аргументов
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    } else {
      const result = fn(...args);
      cache.set(key, result);
      return result;
    }
  };
}
function expensiveCalculation(x, y) {
  console.log(`Вычисление для аргументов ${x} и ${y}`);
  return x + y;
}
const memoizedCalculation = memoize(expensiveCalculation);
//Первый вызов - результат вычисления будет сохранен в кеше
console.log(memoizedCalculation(5, 9));
//Второй вызов с теми же аргументами - результат будет взят из кеша
console.log(memoizedCalculation(5, 9));
 -->

<!-- //1 програма
function logArguments(fn) {
    // Повертаєм нову функцію яка приймає будь-яку кількість аргументів за допомогою оператора rest (...)
    return function (...args) {
        console.log("Arguments:", args);
        // Викликаєм оригінальну функцію fn, використовуючи метод apply передаючи їй аргументи
        return fn.apply(this, args);
    };
}
// Оголошуєм оригінальну функцію exampleFunction яка обчислює суму трьох чисел
function exampleFunction(a, b, c) {
    return a + b + c;
}
// Використовуєм функцію-декоратор logArguments для створення нової функції decoratedExampleFunction
const decoratedExampleFunction = logArguments(exampleFunction);
// Викликаєм decoratedExampleFunction з аргументами
const result = decoratedExampleFunction(6, 8, 2);
console.log("Result:", result);

//2 програма
function validate(fn, validator) {
    return function (...args) {
        // Перевірка аргументів за допомогою валідатора
        if (!validator(...args)) {
            throw new Error("Invalid arguments");
        }
        return fn(...args);
    };
}
// Валідатор який перевіряє чи всі аргументи є числами
function numberValidator(...args) {
    return args.every((arg) => typeof arg === "number");
}
function sumNumbers(a, b) {
    return a + b;
}
// Створення верифікованої функції sumNumbers з використанням валідатора
const validatedSumNumbers = validate(sumNumbers, numberValidator);
// Виклик функції з логікою перевірки аргументів
const outcome = validatedSumNumbers(6, 4);
console.log("Result:", outcome);
try {
    // Спроба викликати функцію з неправильними аргументами
    validatedSumNumbers(10, "invalid");
} catch (error) {
    console.error("Error:", error.message);
}
 -->
<!-- //1 програма
function summarize(num) {
    if (typeof num !== "number") {
        num = 1;
    }
    // Функція яка додає число до аргументу
    return function (arg) {
        // Перевіряєм чи передано аргумент
        if (typeof arg === "number") {
            return num + arg;
        } else {
            // Додаємо одиницю якщо аргумент не передано
            return num + 1;
        }
    };
}
const addFive = summarize(10);
console.log(addFive(2));
console.log(addFive());

//2 програма
function counter(startValue, step) {
    let current = startValue;
    // Метод для збільшення значення на крок
    function increment() {
        current += step;
    }
    // Метод для зменшення значення на крок
    function decrement() {
        current -= step;
    }
    // Метод для скидання значення до початкового
    function reset() {
        current = startValue;
    }
    // Метод для отримання поточного значення
    function getCurrentValue() {
        return current;
    }
    // Повертаєм об'єкт з методами
    return {
        increment,
        decrement,
        reset,
        getCurrentValue,
    };
}
const myCounter = counter(10, 11);
myCounter.increment();
console.log(myCounter.getCurrentValue());
myCounter.decrement();
console.log(myCounter.getCurrentValue());
myCounter.reset();
console.log(myCounter.getCurrentValue());
 -->
<!-- //1 програма
// Конструктор об'єкта Student
function Student(firstName, lastName, birthYear, initialCourse) {
    this.firstName = firstName; // Ім'я студента
    this.lastName = lastName; // Прізвище студента
    this.birthYear = birthYear; // Рік народження студента
    this.courses = [initialCourse]; // Масив, що містить курси, на яких навчається студент
    this.grades = []; // Масив для збереження оцінок студента
    this.attendance = []; // Масив для збереження дат відвідування студента
    // Метод для додавання оцінки студенту
    this.addGrade = function (grade) {
        this.grades.push(grade);
    };
    // Метод для додавання дати відвідування студента
    this.addAttendance = function (date) {
        this.attendance.push(date);
    };
    // Метод для обчислення середньої оцінки студента
    this.getAverageGrade = function () {
        if (this.grades.length === 0) {
            return 0;
        }
        const sum = this.grades.reduce((total, grade) => total + grade);
        return sum / this.grades.length;
    };
    // Метод для обчислення середньої відвідуваності студента
    this.getAverageAttendance = function () {
        if (this.attendance.length === 0) {
            return 0;
        }
        const totalDays = this.attendance.length;
        const presentDays = this.attendance.filter(
            (date) => date.trim() !== ""
        ).length;
        return (presentDays / totalDays) * 100;
    };
    //2 пргограма
    // Метод для зміни курсу студента
    this.changeCourse = function () {
        const newCourse = parseInt(prompt("Введіть новий курс:"));
        if (!isNaN(newCourse) && newCourse >= 1 && newCourse <= 6) {
            this.courses = [newCourse]; // При зміні курсу, стираємо попередні курси і додаємо новий
            console.log(`Курс змінено на ${newCourse}`);
        } else {
            console.log("Помилка: Курс повинен бути від 1 до 6");
        }
    };
    // Метод для додавання нового курсу студентові
    this.addCourse = function () {
        const newCourse = parseInt(prompt("Введіть новий курс для додавання:"));
        if (!isNaN(newCourse) && newCourse >= 1 && newCourse <= 6) {
            if (!this.courses.includes(newCourse)) {
                this.courses.push(newCourse);
                console.log(`Студент навчається на курсі ${newCourse}`);
            } else {
                console.log("Студент вже навчається на цьому курсі");
            }
        } else {
            console.log("Помилка: Курс повинен бути від 1 до 6");
        }
    };
    // Метод для видалення курсу у студента
    this.removeCourse = function () {
        const courseToRemove = parseInt(prompt("Введіть курс для видалення:"));
        if (
            !isNaN(courseToRemove) &&
            courseToRemove >= 1 &&
            courseToRemove <= 6
        ) {
            const index = this.courses.indexOf(courseToRemove);
            if (index !== -1) {
                this.courses.splice(index, 1);
                console.log(
                    `Студент більше не навчається на курсі ${courseToRemove}`
                );
            } else {
                console.log("Студент не навчається на цьому курсі");
            }
        } else {
            console.log("Помилка: Курс повинен бути від 1 до 6");
        }
    };
    // Метод для отримання інформації про студента
    this.getInfo = function () {
        return `Ім'я: ${this.firstName}, Прізвище: ${
            this.lastName
        }, Рік народження: ${this.birthYear}, Курси: ${this.courses.join(
            ", "
        )}, Оцінки: ${this.grades.join(
            ", "
        )}, Відвідуваність: ${this.attendance.join(", ")}`;
    };
    // Метод для отримання кількості занять, на які студент відвідав
    this.getNumberOfClassesAttended = function () {
        return this.attendance.length;
    };
}
const firstName = prompt("Введіть ім'я студента:");
const lastName = prompt("Введіть прізвище студента:");
const birthYear = parseInt(prompt("Введіть рік народження студента:"));

let initialCourse;
while (true) {
    initialCourse = parseInt(prompt("Введіть початковий курс студента:"));
    if (!isNaN(initialCourse) && initialCourse >= 1 && initialCourse <= 6) {
        break;
    } else {
        alert("Початковий курс повинен бути числом від 1 до 6.");
    }
}
const student = new Student(firstName, lastName, birthYear, initialCourse);
while (true) {
    const gradeInput = prompt(
        "Введіть оцінку студента (або натисніть 'Скасувати'):"
    );
    if (gradeInput === null || gradeInput.trim() === "") {
        break;
    }
    const grade = parseFloat(gradeInput);
    if (!isNaN(grade)) {
        student.addGrade(grade);
    }
}
while (true) {
    const attendanceDate = prompt(
        "Введіть дату відвідування студента (або натисніть 'Скасувати'):"
    );
    if (attendanceDate === null || attendanceDate.trim() === "") {
        break;
    }
    student.addAttendance(attendanceDate);
}
// Виводимо інформацію про студента
console.log(student.getInfo());
// Розраховуємо середню успішність та відвідуваність
console.log(
    "Кількість пройдених занять:",
    student.getNumberOfClassesAttended()
);
console.log("Середня успішність:", student.getAverageGrade());
console.log("Середнє відвідування:", student.getAverageAttendance() + "%");
student.changeCourse();

while (true) {
    const action = prompt(
        "Ви хочете додати (напишіть 'додати') чи видалити (напишіть 'видалити') курс? (або натисніть 'Скасувати' для завершення):"
    );
    if (action === null || action.trim() === "") {
        break;
    }
    if (action === "додати") {
        student.addCourse();
    } else if (action === "видалити") {
        student.removeCourse();
    } else {
        console.log("Невірна команда. Введіть 'додати' або 'видалити'.");
    }
}
console.log("Оновлена інформація про студента:");
console.log(student.getInfo());

// //3 програма
function Student(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.grades = [];
    this.attendance = [];

    this.addGrade = function (grade) {
        this.grades.push(grade);
    };
    this.addAttendance = function (status) {
        this.attendance.push(status);
    };
    this.getAverageGrade = function () {
        if (this.grades.length === 0) {
            return 0;
        }
        const sum = this.grades.reduce((total, grade) => total + grade);
        return sum / this.grades.length;
    };
    this.getAverageAttendance = function () {
        if (this.attendance.length === 0) {
            return 0;
        }
        const totalDays = this.attendance.length;
        const presentDays = this.attendance.filter(
            (status) => status === "Присутній"
        ).length;
        return (presentDays / totalDays) * 100;
    };
    this.getRating = function () {
        const averageGrade = this.getAverageGrade();
        const averageAttendance = this.getAverageAttendance();
        return (averageGrade + averageAttendance) / 2;
    };
    this.getInfo = function () {
        return `Ім'я: ${this.firstName}, Прізвище: ${
            this.lastName
        }, Середній бал: ${this.getAverageGrade().toFixed(
            2
        )}, Відвідуваність: ${this.getAverageAttendance().toFixed(
            2
        )}%, Рейтинг: ${this.getRating().toFixed(2)}`;
    };
}

function Group() {
    this.students = [];
    this.addStudent = function (student) {
        this.students.push(student);
        console.log(
            `Додано студента: ${student.firstName} ${student.lastName}`
        );
    };
    this.removeStudent = function (student) {
        const index = this.students.indexOf(student);
        if (index !== -1) {
            this.students.splice(index, 1);
            console.log(
                `Видалено студента: ${student.firstName} ${student.lastName}`
            );
        }
    };
    this.getStudentsRating = function () {
        const ratings = [];
        this.students.forEach((student, index) => {
            const rating = student.getRating();
            ratings.push({
                studentNumber: index + 1,
                firstName: student.firstName,
                lastName: student.lastName,
                rating: rating.toFixed(2),
                attendance: student.getAverageAttendance().toFixed(2),
            });
        });
        return ratings;
    };
    this.printStudents = function () {
        console.log("Список студентів:");
        this.students.forEach((student, index) => {
            console.log(
                `${index + 1}. ${student.firstName} ${student.lastName}`
            );
        });
    };
}

// Функція для введення інформації про студента
function enterStudentInfo() {
    const firstName = prompt("Введіть ім'я студента:");
    const lastName = prompt("Введіть прізвище студента:");
    const student = new Student(firstName, lastName);

    return student;
}

// Функція для введення інформації про оцінки та відвідуваність
function enterStudentData(student) {
    while (true) {
        const gradeInput = prompt(
            "Введіть оцінку студента (або натисніть 'Скасувати'):"
        );
        if (gradeInput === null || gradeInput.trim() === "") {
            break;
        }
        const grade = parseFloat(gradeInput);
        if (!isNaN(grade)) {
            student.addGrade(grade);
        }
    }

    while (true) {
        const attendanceStatus = prompt(
            "Введіть статус відвідуваності студента (Присутній/Відсутній) " +
                "(або натисніть 'Скасувати'):"
        );
        if (attendanceStatus === null || attendanceStatus.trim() === "") {
            break;
        }
        student.addAttendance(attendanceStatus);
    }
}

const group = new Group();

while (true) {
    const action = prompt(
        "Ви хочете додати нового студента (напишіть 'додати') чи завершити (напишіть 'завершити')? " +
            "(або натисніть 'Скасувати':"
    );
    if (
        action === null ||
        action.trim() === "" ||
        action.toLowerCase() === "завершити"
    ) {
        break;
    } else if (action.toLowerCase() === "додати") {
        const student = enterStudentInfo();
        enterStudentData(student);
        group.addStudent(student);
        group.printStudents();
    }
}
const ratings = group.getStudentsRating();
console.log("Рейтинг студентів:");
ratings.forEach((student) => {
    console.log(
        `${student.studentNumber}. ${student.firstName} ${student.lastName} - Рейтинг: ${student.rating}, Відвідуваність: ${student.attendance}%`
    );
});
 -->

<!-- // Клас TodoList для керування списком нотаток
class TodoList {
    constructor() {
        this.notes = [];
    }
    // Додавання нової нотатки
    addNote(noteText) {
        if (noteText.trim() !== "") {
            const currentDate = new Date();
            this.notes.push({
                text: noteText,
                completed: false,
                createdDate: currentDate,
                editedDate: null,
            });
        }
    }
    // Редагування існуючої нотатки за індексом
    editNote(index, newText) {
        if (index >= 0 && index < this.notes.length) {
            const currentDate = new Date();
            this.notes[index].text = newText;
            this.notes[index].editedDate = currentDate;
        }
    }
    // Видалення нотатки за індексом
    deleteNote(index) {
        if (index >= 0 && index < this.notes.length) {
            this.notes.splice(index, 1);
        }
    }
    // Зміна статусу виконання нотатки за індексом
    toggleNoteStatus(index) {
        if (index >= 0 && index < this.notes.length) {
            this.notes[index].completed = !this.notes[index].completed;
        }
    }
    // Отримання списку нотаток
    getNoteList() {
        return this.notes;
    }
    // Отримання загальної кількості нотаток
    getNoteCount() {
        return this.notes.length;
    }
    // Отримання кількості невиконаних нотаток
    getRemainingNoteCount() {
        return this.notes.filter((note) => !note.completed).length;
    }
    // Позначення нотатки як виконаної за індексом
    markNoteAsCompleted(index) {
        if (index >= 0 && index < this.notes.length) {
            this.notes[index].completed = true;
        }
    }
    // Отримання кількості виконаних нотаток
    getCompletedNoteCount() {
        return this.notes.filter((note) => note.completed).length;
    }
    // Пошук нотаток за іменем
    searchNotesByName(name) {
        return this.notes.filter((note) =>
            note.text.toLowerCase().includes(name.toLowerCase())
        );
    }
    // Сортування нотаток за статусом
    sortNotesByStatus(completedFirst = true) {
        if (completedFirst) {
            return this.notes
                .slice()
                .sort((a, b) =>
                    a.completed === b.completed ? 0 : a.completed ? -1 : 1
                );
        } else {
            return this.notes
                .slice()
                .sort((a, b) =>
                    a.completed === b.completed ? 0 : a.completed ? 1 : -1
                );
        }
    }
}

// Створення екземпляра TodoList
const todoList = new TodoList();

// Отримання DOM-елементів
const noteInput = document.getElementById("noteInput");
const addButton = document.getElementById("addButton");
const noteList = document.getElementById("noteList");
const totalNotes = document.getElementById("totalNotes");
const remainingNotes = document.getElementById("remainingNotes");
const completedNotesCount = document.getElementById("completedNotesCount");

// Функція для оновлення відображення нотаток
function updateNoteDisplay() {
    noteList.innerHTML = "";
    const notes = todoList.getNoteList();
    totalNotes.textContent = todoList.getNoteCount();
    remainingNotes.textContent = todoList.getRemainingNoteCount();
    completedNotesCount.textContent = todoList.getCompletedNoteCount();

    // Створення HTML-елементів для кожної нотатки
    notes.forEach((note, index) => {
        const noteItem = document.createElement("div");
        noteItem.className = `note ${note.completed ? "completed" : ""}`;
        noteItem.innerHTML = `
            <span class="note-text">${note.text}</span>
            <button class="edit-button" data-index="${index}">${
            note.completed ? "Переглянути" : "Редагувати"
        }</button>
            <button class="delete-button" data-index="${index}">Видалити</button>
            <button class="complete-button" data-index="${index}">${
            note.completed ? "Скасувати виконання" : "Позначити як виконану"
        }</button>
        `;

        // Додавання обробника подій на кнопку "complete-button"
        const completeButton = noteItem.querySelector(".complete-button");
        completeButton.addEventListener("click", () => {
            if (note.completed) {
                todoList.toggleNoteStatus(index);
                updateNoteDisplay();
            } else {
                todoList.markNoteAsCompleted(index);
                updateNoteDisplay();
            }
        });

        // Додавання нотатки до списку
        noteList.appendChild(noteItem);
    });
}

// Оновлення відображення при завантаженні сторінки
updateNoteDisplay();

// Додавання нотатки при кліку на кнопку "Добавити"
addButton.addEventListener("click", () => {
    const noteText = noteInput.value;
    todoList.addNote(noteText);
    noteInput.value = "";
    updateNoteDisplay();
});

// Обробка подій кліку на кнопки "Редагувати" та "Видалити"
noteList.addEventListener("click", (event) => {
    if (event.target.classList.contains("edit-button")) {
        const index = event.target.getAttribute("data-index");
        const newText = prompt(
            "Редагувати:",
            todoList.getNoteList()[index].text
        );
        if (newText !== null) {
            todoList.editNote(index, newText);
            updateNoteDisplay();
        }
    }

    if (event.target.classList.contains("delete-button")) {
        const index = event.target.getAttribute("data-index");
        if (confirm("Видалити?")) {
            todoList.deleteNote(index);
            updateNoteDisplay();
        }
    }
});

//2 Додавання обробника події для кнопки "Пошук"
const searchButton = document.getElementById("searchButton");
const searchInput = document.getElementById("searchInput");

searchButton.addEventListener("click", () => {
    const searchText = searchInput.value.trim();
    const searchResults = todoList.searchNotesByName(searchText);
    displayNotes(searchResults);
});
// Додавання обробника події для кнопки "Сортувати"
const sortButton = document.getElementById("sortButton");
const sortSelect = document.getElementById("sortSelect");

sortButton.addEventListener("click", () => {
    const sortByCompletedFirst = sortSelect.value === "completedFirst";
    const sortedNotes = todoList.sortNotesByStatus(sortByCompletedFirst);
    displayNotes(sortedNotes);
});

function displayNotes(notes) {
    noteList.innerHTML = "";
    totalNotes.textContent = notes.length;

    notes.forEach((note, index) => {
        const noteItem = document.createElement("div");
        noteItem.className = `note ${note.completed ? "completed" : ""}`;
        noteItem.innerHTML = `
            <span class="note-text">${note.text}</span>
            <p class="created-date">Створений: ${note.createdDate.toLocaleString()}</p>
            <p class="edited-date">Відредаговано: ${
                note.editedDate
                    ? note.editedDate.toLocaleString()
                    : "Не відредаговано"
            }</p>
            <button class="edit-button" data-index="${index}">${
            note.completed ? "Переглянути" : "Редагувати"
        }</button>
            <button class="delete-button" data-index="${index}">Видалити</button>
            <button class="complete-button" data-index="${index}">${
            note.completed ? "Скасувати виконання" : "Позначити як виконану"
        }</button>
        `;

        // Додавання обробників подій на кнопки
        const completeButton = noteItem.querySelector(".complete-button");
        completeButton.addEventListener("click", () => {
            if (note.completed) {
                todoList.toggleNoteStatus(index);
                displayNotes(notes);
            } else {
                todoList.markNoteAsCompleted(index);
                displayNotes(notes);
            }

            // Оновити список нотаток із відповідними індексами
            displayNotes(
                todoList.sortNotesByStatus(
                    sortSelect.value === "completedFirst"
                )
            );
        });

        noteList.appendChild(noteItem);
    });
}
// Оновлення відображення при завантаженні сторінки
todoList.updateNoteDisplay();
 -->
